//
// Generated by JTB 1.3.2
//

package visitor;
import syntaxtree.*;
import java.util.*;
/**
 * Provides default methods which visit each node in the tree in depth-first
 * order.  Your visitors may extend this class.
 */
public class GJNoArguDepthFirst<R> implements GJNoArguVisitor<R> {
   //
   // Auto class visitors--probably don't need to be overridden.
   //
	public HashMap<String,classnode> classmap = new HashMap<String,classnode>();
	HashMap<String,String> methodmap;
	HashMap<String,String> variablemap;
	boolean var = false;
	
	class methodnode{
		public R methodname;
		public R scope;
		public R ret; 
		public R signature;
		public methodnode(){
			methodname = null;
			scope = null;
			ret = null;
			signature = null;
		}
	}
	
	public class classnode{
		public String name;
		public String parentname;
		public HashMap<String,String> methodmap;
		public HashMap<String,String> variablemap;
		public classnode(){
			name = null;
			parentname = null;
			methodmap = null;
			variablemap = null;
		}
		
	}
	
	LinkedHashMap<String,String> scope = new LinkedHashMap<String,String>();
	String classname;
	String methodname="";
	String fparam;
	String typeIdent;
	
	public void checkOverloadingVar(String s , String type , classnode c){
		String v;
		if(c.variablemap.containsKey(s)){
			v = c.variablemap.get(s);
			if(v.equals(type)){
				if(c.parentname != null){
					checkOverloadingVar(s, type, classmap.get(c.parentname));
				}
			}else{
				System.out.println("Type error");
				System.exit(0);
			}
		}
	}
	public void assignable(String s, String f){
		   if((f.equals("int"))||(f.equals("int []"))||(f.equals("boolean"))){
			   
			   if(f.equals(s)){
				   return;
			   }else{
				   System.out.println("Type error");
				   System.exit(0);   
			   }
		   }
		   if(f.equals(s)){
			   return;
		   }else if(classmap.get(f).parentname!=null){
			   assignable(s, classmap.get(f).parentname);
			   return; 
		   }else{
			   System.out.println("Type error");
			   System.exit(0);
		   }
	   }
	public void checkOverloadingMet(String s , String type1 , classnode c){
		String v;
		String type = type1.split("-", 2)[0];
		String ret = type1.split(">", 2)[1];
		if(c.methodmap.containsKey(s)){
			v = c.methodmap.get(s);
			String abs[] = v.split("-", 2);
			String retpar[] = v.split(">", 2);
			if(abs[0].equals(type)){
				assignable(retpar[1],ret);
				if(c.parentname != null){
					checkOverloadingMet(s, type1, classmap.get(c.parentname));
				}
			}else{
				//System.out.println(s + " " + type);
				System.out.println("Type error");
				System.exit(0);
			}
		}
	}
	
	public void checkType(String s){
		if(s.equals("int")||s.equals("boolean")||s.equals("int []")){
			return;
		}
		if(classmap.containsKey(s)){
			return;
		}else{
			System.out.println("Type error");
			System.exit(0);
		}
	}
	
   public R visit(NodeList n) {
      R _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this);
         _count++;
      }
      return _ret;
   }

   public R visit(NodeListOptional n) {
      if ( n.present() ) {
         R _ret=null;
         int _count=0;
         for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
            e.nextElement().accept(this);
            _count++;
         }
         return _ret;
      }
      else
         return null;
   }

   public R visit(NodeOptional n) {
      if ( n.present() )
         return n.node.accept(this);
      else
         return null;
   }

   public R visit(NodeSequence n) {
      R _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this);
         _count++;
      }
      return _ret;
   }

   public R visit(NodeToken n) { return null; }

   //
   // User-generated visitor methods below
   //
   
   public void checkLoop(String s , String parent){
	   if(s.equals(parent)){
		   System.out.println("Type error");
		   System.exit(0);
	   }else{
		   if(classmap.get(parent).parentname!=null){
			   checkLoop(s,classmap.get(parent).parentname);
		   }
	   }
   }
   public void checkParent(){
	   Iterator<String> keySetIterator = classmap.keySet().iterator();
	   while(keySetIterator.hasNext()){
		   String c = keySetIterator.next();
		   if(classmap.get(c).parentname != null){
			   checkLoop(c,classmap.get(c).parentname);
			   if(classmap.containsKey(classmap.get(c).parentname)){
				   
			   }else{
				   System.out.println("Type error");
				   System.exit(0);
			   }
		   }
	   }
	}
   
   /**
    * f0 -> MainClass()
    * f1 -> ( TypeDeclaration() )*
    * f2 -> <EOF>
    */
   public R visit(Goal n) {
      R _ret=null;
      n.f0.accept(this);
      n.f1.accept(this);
      n.f2.accept(this);
      checkParent();
      Iterator<String> keySetIterator = classmap.keySet().iterator();
      while(keySetIterator.hasNext()){
    	  String key = keySetIterator.next();
    	  //System.out.println(key + "\t\t" + scope.get(key));
    	  //System.out.println(key);
    	  Iterator<String> varSetIterator = classmap.get(key).variablemap.keySet().iterator();
    	  while(varSetIterator.hasNext()){
    		  String var = varSetIterator.next();
    		  //System.out.println(var);
    		  checkType(classmap.get(key).variablemap.get(var));
    		//  if(classmap.get(key).parentname != null){
    			//  checkOverloadingVar(var,classmap.get(key).variablemap.get(var) , classmap.get(classmap.get(key).parentname));
    		  //}
    	  }
    	  //System.out.println();
    	  Iterator<String> metSetIterator = classmap.get(key).methodmap.keySet().iterator();
    	  while(metSetIterator.hasNext()){
    		  String met = metSetIterator.next();
    		  String abs[] = classmap.get(key).methodmap.get(met).split("-", 2);
    		  //System.out.println(met + " " + classmap.get(key).methodmap.get(met));
    		  if(classmap.get(key).parentname != null){
    			  checkOverloadingMet(met, classmap.get(key).methodmap.get(met) , classmap.get(classmap.get(key).parentname));
    		  }//changed abs[0] to classmap.get(key).methodmap.get(met)
    	  }
    	}
      _ret = (R)classmap;
      return _ret;
   }

   /**
    * f0 -> "class"
    * f1 -> Identifier()
    * f2 -> "{"
    * f3 -> "public"
    * f4 -> "static"
    * f5 -> "void"
    * f6 -> "main"
    * f7 -> "("
    * f8 -> "String"
    * f9 -> "["
    * f10 -> "]"
    * f11 -> Identifier()
    * f12 -> ")"
    * f13 -> "{"
    * f14 -> PrintStatement()
    * f15 -> "}"
    * f16 -> "}"
    */
   public R visit(MainClass n) {
      R _ret=null;
      classnode c = new classnode();
      var = true;
      n.f0.accept(this);
      n.f1.accept(this);
      methodmap = new HashMap<String,String>();
      variablemap = new HashMap<String,String>();
      c.parentname = new String();
      c.parentname = null;
      c.name = new String();
      c.name = "Main";
      scope.put(n.f1.f0.toString(),"Main class");
      scope.put(n.f1.f0.toString()+':'+n.f11.f0.toString(),"String[]");
      n.f2.accept(this);
      n.f3.accept(this);
      n.f4.accept(this);
      n.f5.accept(this);
      n.f6.accept(this);
      n.f7.accept(this);
      n.f8.accept(this);
      n.f9.accept(this);
      n.f10.accept(this);
      n.f11.accept(this);
      n.f12.accept(this);
      n.f13.accept(this);
      n.f14.accept(this);
      n.f15.accept(this);
      n.f16.accept(this);
      c.methodmap = methodmap;
      methodmap = null;
      c.variablemap = variablemap;
      variablemap = null;
      classmap.put(c.name, c);
      return _ret;
   }

   /**
    * f0 -> ClassDeclaration()
    *       | ClassExtendsDeclaration()
    */
   public R visit(TypeDeclaration n) {
      R _ret=null;
      n.f0.accept(this);
      return _ret;
   }

   /**
    * f0 -> "class"
    * f1 -> Identifier()
    * f2 -> "{"
    * f3 -> ( VarDeclaration() )*
    * f4 -> ( MethodDeclaration() )*
    * f5 -> "}"
    */
   public R visit(ClassDeclaration n) {
      R _ret=null;
      classnode c = new classnode();
      var = true;
      methodmap = new HashMap<String,String>();
      variablemap = new HashMap<String,String>();
      n.f0.accept(this);
      n.f1.accept(this);
      c.name = new String();
      c.name = n.f1.f0.toString();
      c.parentname = new String();
      c.parentname = null;
      classname = n.f1.f0.toString();
      scope.put(classname,"class");
      n.f2.accept(this);
      n.f3.accept(this);
      n.f4.accept(this);
      n.f5.accept(this);
      classname="";
      c.methodmap = methodmap;
      c.variablemap = variablemap;
      methodmap = null;
      variablemap = null;
      if(classmap.containsKey(c.name)){
    	  System.out.println("Type error");
    	  System.exit(0);
      }
      classmap.put(c.name, c);
      return _ret;
   }

   /**
    * f0 -> "class"
    * f1 -> Identifier()
    * f2 -> "extends"
    * f3 -> Identifier()
    * f4 -> "{"
    * f5 -> ( VarDeclaration() )*
    * f6 -> ( MethodDeclaration() )*
    * f7 -> "}"
    */
   public R visit(ClassExtendsDeclaration n) {
      R _ret=null;
      classnode c = new classnode();
      var = true;
      methodmap = new HashMap<String,String>();
      variablemap = new HashMap<String,String>();
      n.f0.accept(this);
      n.f1.accept(this);
      c.name = new String();
      c.name = n.f1.f0.toString();
      n.f2.accept(this);
      n.f3.accept(this);
      c.parentname = new String();
      c.parentname = n.f3.f0.toString();
      n.f4.accept(this);
      n.f5.accept(this);
      n.f6.accept(this);
      n.f7.accept(this);
      c.methodmap = methodmap;
      c.variablemap = variablemap;
      methodmap = null;
      variablemap = null;
      if(classmap.containsKey(c.name)){
    	  System.out.println("Type error");
    	  System.exit(0);
      }
      classmap.put(c.name, c);
      return _ret;
   }

   /**
    * f0 -> Type()
    * f1 -> Identifier()
    * f2 -> ";"
    */
   public R visit(VarDeclaration n) {
      R _ret=null;
      n.f0.accept(this);
      String type="" ;
      switch(n.f0.f0.which)
      {
      	case 0 : type = "int []";
               break;
      	case 1 : type = "boolean";
      	break;
      	case 2 : type = "int";
      	break;
      	case 3 : type = typeIdent;
      	break;
      }
      if(methodname!=""){
    	  scope.put(classname+":"+methodname+":"+n.f1.f0.toString(),type);
      }else{
    	  scope.put(classname+":"+n.f1.f0.toString(),type);
      }
      if(var){
    	  if((variablemap.containsKey(n.f1.f0.toString()))&&(variablemap.containsValue(type))){
    		  System.out.println("Type error");
    		  System.exit(0);
    	  }
    	  variablemap.put( n.f1.f0.toString(),type);
      }
      n.f1.accept(this);
      n.f2.accept(this);
      return _ret;
   }

   /**
    * f0 -> "public"
    * f1 -> Type()
    * f2 -> Identifier()
    * f3 -> "("
    * f4 -> ( FormalParameterList() )?
    * f5 -> ")"
    * f6 -> "{"
    * f7 -> ( VarDeclaration() )*
    * f8 -> ( Statement() )*
    * f9 -> "return"
    * f10 -> Expression()
    * f11 -> ";"
    * f12 -> "}"
    */
   public R visit(MethodDeclaration n) {
      R _ret=null;
      var = false;
      methodname = n.f2.f0.toString();
      n.f0.accept(this);
      n.f1.accept(this);
      String type="" ;
      switch(n.f1.f0.which)
      {
      	case 0 : type = "int []";
               break;
      	case 1 : type = "boolean";
      	break;
      	case 2 : type = "int";
      	break;
      	case 3 : type = typeIdent;
      	break;
      }
      n.f2.accept(this);
      
     
      n.f3.accept(this);
      fparam="";
      n.f4.accept(this);
      scope.put(classname+":"+methodname,'('+fparam+')'+"-->"+type);
      n.f5.accept(this);
      n.f6.accept(this);
      n.f7.accept(this);
      n.f8.accept(this);
      n.f9.accept(this);
      n.f10.accept(this);
      n.f11.accept(this);
      n.f12.accept(this);
      if((methodmap.containsKey(methodname))){
    	  String s = methodmap.get(methodname);
    	  String a[] = s.split("-->", 2);
    	  if(a[0].equals('('+fparam+')')){
    		  System.out.println("Type error");
    		  System.exit(0);
    	  }
      }
      methodmap.put(methodname, '('+fparam+')'+"-->"+type);
      methodname="";
      return _ret;
   }

   /**
    * f0 -> FormalParameter()
    * f1 -> ( FormalParameterRest() )*
    */
   public R visit(FormalParameterList n) {
      R _ret=null;
      n.f0.accept(this);
      n.f1.accept(this);
      return _ret;
   }

   /**
    * f0 -> Type()
    * f1 -> Identifier()
    */
   public R visit(FormalParameter n) {
      R _ret=null;
      n.f0.accept(this);
      
      String type="" ;
      switch(n.f0.f0.which)
      {
      	case 0 : type = "int []";
               break;
      	case 1 : type = "boolean";
      	break;
      	case 2 : type = "int";
      	break;
      	case 3 : type = typeIdent;
      	break;
      }
      n.f1.accept(this);
      if(fparam!="")
      fparam = fparam+","+type;
      else fparam = type;
      scope.put(classname+":"+methodname+":"+n.f1.f0.toString(),type);
      return _ret;
   }

   /**
    * f0 -> ","
    * f1 -> FormalParameter()
    */
   public R visit(FormalParameterRest n) {
      R _ret=null;
      n.f0.accept(this);
      n.f1.accept(this);
      return _ret;
   }

   /**
    * f0 -> ArrayType()
    *       | BooleanType()
    *       | IntegerType()
    *       | Identifier()
    */
   public R visit(Type n) {
      R _ret=null;
      n.f0.accept(this);
      return _ret;
   }

   /**
    * f0 -> "int"
    * f1 -> "["
    * f2 -> "]"
    */
   public R visit(ArrayType n) {
      R _ret=null;
      n.f0.accept(this);
      n.f1.accept(this);
      n.f2.accept(this);
      return _ret;
   }

   /**
    * f0 -> "boolean"
    */
   public R visit(BooleanType n) {
      R _ret=null;
      n.f0.accept(this);
      return _ret;
   }

   /**
    * f0 -> "int"
    */
   public R visit(IntegerType n) {
      R _ret=null;
      n.f0.accept(this);
      return _ret;
   }

   /**
    * f0 -> Block()
    *       | AssignmentStatement()
    *       | ArrayAssignmentStatement()
    *       | IfStatement()
    *       | WhileStatement()
    *       | PrintStatement()
    */
   public R visit(Statement n) {
      R _ret=null;
      n.f0.accept(this);
      return _ret;
   }

   /**
    * f0 -> "{"
    * f1 -> ( Statement() )*
    * f2 -> "}"
    */
   public R visit(Block n) {
      R _ret=null;
      n.f0.accept(this);
      n.f1.accept(this);
      n.f2.accept(this);
      return _ret;
   }

   /**
    * f0 -> Identifier()
    * f1 -> "="
    * f2 -> Expression()
    * f3 -> ";"
    */
   public R visit(AssignmentStatement n) {
      R _ret=null;
      n.f0.accept(this);
      n.f1.accept(this);
      n.f2.accept(this);
      n.f3.accept(this);
      return _ret;
   }

   /**
    * f0 -> Identifier()
    * f1 -> "["
    * f2 -> Expression()
    * f3 -> "]"
    * f4 -> "="
    * f5 -> Expression()
    * f6 -> ";"
    */
   public R visit(ArrayAssignmentStatement n) {
      R _ret=null;
      n.f0.accept(this);
      n.f1.accept(this);
      n.f2.accept(this);
      n.f3.accept(this);
      n.f4.accept(this);
      n.f5.accept(this);
      n.f6.accept(this);
      return _ret;
   }

   /**
    * f0 -> "if"
    * f1 -> "("
    * f2 -> Expression()
    * f3 -> ")"
    * f4 -> Statement()
    * f5 -> "else"
    * f6 -> Statement()
    */
   public R visit(IfStatement n) {
      R _ret=null;
      n.f0.accept(this);
      n.f1.accept(this);
      n.f2.accept(this);
      n.f3.accept(this);
      n.f4.accept(this);
      n.f5.accept(this);
      n.f6.accept(this);
      return _ret;
   }

   /**
    * f0 -> "while"
    * f1 -> "("
    * f2 -> Expression()
    * f3 -> ")"
    * f4 -> Statement()
    */
   public R visit(WhileStatement n) {
      R _ret=null;
      n.f0.accept(this);
      n.f1.accept(this);
      n.f2.accept(this);
      n.f3.accept(this);
      n.f4.accept(this);
      return _ret;
   }

   /**
    * f0 -> "System.out.println"
    * f1 -> "("
    * f2 -> Expression()
    * f3 -> ")"
    * f4 -> ";"
    */
   public R visit(PrintStatement n) {
      R _ret=null;
      n.f0.accept(this);
      n.f1.accept(this);
      n.f2.accept(this);
      n.f3.accept(this);
      n.f4.accept(this);
      return _ret;
   }

   /**
    * f0 -> AndExpression()
    *       | CompareExpression()
    *       | PlusExpression()
    *       | MinusExpression()
    *       | TimesExpression()
    *       | ArrayLookup()
    *       | ArrayLength()
    *       | MessageSend()
    *       | PrimaryExpression()
    */
   public R visit(Expression n) {
      R _ret=null;
      n.f0.accept(this);
      return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "&"
    * f2 -> PrimaryExpression()
    */
   public R visit(AndExpression n) {
      R _ret=null;
      n.f0.accept(this);
      n.f1.accept(this);
      n.f2.accept(this);
      return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "<"
    * f2 -> PrimaryExpression()
    */
   public R visit(CompareExpression n) {
      R _ret=null;
      n.f0.accept(this);
      n.f1.accept(this);
      n.f2.accept(this);
      return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "+"
    * f2 -> PrimaryExpression()
    */
   public R visit(PlusExpression n) {
      R _ret=null;
      n.f0.accept(this);
      n.f1.accept(this);
      n.f2.accept(this);
      return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "-"
    * f2 -> PrimaryExpression()
    */
   public R visit(MinusExpression n) {
      R _ret=null;
      n.f0.accept(this);
      n.f1.accept(this);
      n.f2.accept(this);
      return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "*"
    * f2 -> PrimaryExpression()
    */
   public R visit(TimesExpression n) {
      R _ret=null;
      n.f0.accept(this);
      n.f1.accept(this);
      n.f2.accept(this);
      return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "["
    * f2 -> PrimaryExpression()
    * f3 -> "]"
    */
   public R visit(ArrayLookup n) {
      R _ret=null;
      n.f0.accept(this);
      n.f1.accept(this);
      n.f2.accept(this);
      n.f3.accept(this);
      return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "."
    * f2 -> "length"
    */
   public R visit(ArrayLength n) {
      R _ret=null;
      n.f0.accept(this);
      n.f1.accept(this);
      n.f2.accept(this);
      return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "."
    * f2 -> Identifier()
    * f3 -> "("
    * f4 -> ( ExpressionList() )?
    * f5 -> ")"
    */
   public R visit(MessageSend n) {
      R _ret=null;
      n.f0.accept(this);
      n.f1.accept(this);
      n.f2.accept(this);
      n.f3.accept(this);
      n.f4.accept(this);
      n.f5.accept(this);
      return _ret;
   }

   /**
    * f0 -> Expression()
    * f1 -> ( ExpressionRest() )*
    */
   public R visit(ExpressionList n) {
      R _ret=null;
      n.f0.accept(this);
      n.f1.accept(this);
      return _ret;
   }

   /**
    * f0 -> ","
    * f1 -> Expression()
    */
   public R visit(ExpressionRest n) {
      R _ret=null;
      n.f0.accept(this);
      n.f1.accept(this);
      return _ret;
   }

   /**
    * f0 -> IntegerLiteral()
    *       | TrueLiteral()
    *       | FalseLiteral()
    *       | Identifier()
    *       | ThisExpression()
    *       | ArrayAllocationExpression()
    *       | AllocationExpression()
    *       | NotExpression()
    *       | BracketExpression()
    */
   public R visit(PrimaryExpression n) {
      R _ret=null;
      n.f0.accept(this);
      return _ret;
   }

   /**
    * f0 -> <INTEGER_LITERAL>
    */
   public R visit(IntegerLiteral n) {
      R _ret=null;
      n.f0.accept(this);
      return _ret;
   }

   /**
    * f0 -> "true"
    */
   public R visit(TrueLiteral n) {
      R _ret=null;
      n.f0.accept(this);
      return _ret;
   }

   /**
    * f0 -> "false"
    */
   public R visit(FalseLiteral n) {
      R _ret=null;
      n.f0.accept(this);
      return _ret;
   }

   /**
    * f0 -> <IDENTIFIER>
    */
   public R visit(Identifier n) {
      R _ret=null;
      n.f0.accept(this);
      typeIdent = n.f0.toString();
      return _ret;
   }

   /**
    * f0 -> "this"
    */
   public R visit(ThisExpression n) {
      R _ret=null;
      n.f0.accept(this);
      return _ret;
   }

   /**
    * f0 -> "new"
    * f1 -> "int"
    * f2 -> "["
    * f3 -> Expression()
    * f4 -> "]"
    */
   public R visit(ArrayAllocationExpression n) {
      R _ret=null;
      n.f0.accept(this);
      n.f1.accept(this);
      n.f2.accept(this);
      n.f3.accept(this);
      n.f4.accept(this);
      return _ret;
   }

   /**
    * f0 -> "new"
    * f1 -> Identifier()
    * f2 -> "("
    * f3 -> ")"
    */
   public R visit(AllocationExpression n) {
      R _ret=null;
      n.f0.accept(this);
      n.f1.accept(this);
      n.f2.accept(this);
      n.f3.accept(this);
      return _ret;
   }

   /**
    * f0 -> "!"
    * f1 -> Expression()
    */
   public R visit(NotExpression n) {
      R _ret=null;
      n.f0.accept(this);
      n.f1.accept(this);
      return _ret;
   }

   /**
    * f0 -> "("
    * f1 -> Expression()
    * f2 -> ")"
    */
   public R visit(BracketExpression n) {
      R _ret=null;
      n.f0.accept(this);
      n.f1.accept(this);
      n.f2.accept(this);
      return _ret;
   }

}
